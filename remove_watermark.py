#!/usr/bin/env python3
"""Gemini Watermark Remover
Remove visible watermark of images generated by Nano Banana (Gemini's AI image generator).

Usage:
    python remove_watermark.py input.png [input2.png ...] [--out OUTPUT] [-O OUTPUT] [--force-small] [--force-large]
"""

from __future__ import annotations

import argparse
import sys
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Final

import cv2
import numpy as np

__version__ = "0.1.0"

LOGO_VALUE: Final[float] = 255.0
ALPHA_THRESHOLD: Final[float] = 0.002
MAX_ALPHA: Final[float] = 0.99
LARGE_SIZE_THRESHOLD: Final[int] = 1024


class WatermarkSize(str, Enum):
    SMALL = "small"
    LARGE = "large"


@dataclass(frozen=True, slots=True)
class WatermarkConfig:
    margin_right: int
    margin_bottom: int
    logo_size: int
    alpha_map: np.ndarray


class WatermarkRemover:
    """
    Removes Gemini watermarks using reverse alpha blending.

    Algorithm: original = (result - logo * alpha) / (1 - alpha)
    """

    def __init__(self, watermark_48_path: str | Path, watermark_96_path: str | Path) -> None:
        self.bg_48: np.ndarray = self._load_watermark(watermark_48_path)
        self.bg_96: np.ndarray = self._load_watermark(watermark_96_path)

        self.alpha_48: np.ndarray = self._calculate_alpha_map(self.bg_48)
        self.alpha_96: np.ndarray = self._calculate_alpha_map(self.bg_96)

        # Use loaded watermarks as templates for detection
        self.template_48: np.ndarray = cv2.cvtColor(self.bg_48, cv2.COLOR_BGR2GRAY)
        self.template_96: np.ndarray = cv2.cvtColor(self.bg_96, cv2.COLOR_BGR2GRAY)

    def _load_watermark(self, file_path: str | Path) -> np.ndarray:
        file_path = Path(file_path)
        watermark = cv2.imread(str(file_path), cv2.IMREAD_COLOR)
        if watermark is None:
            raise FileNotFoundError(f"Failed to load watermark: {file_path}")
        return watermark

    def _calculate_alpha_map(self, bg_capture: np.ndarray) -> np.ndarray:
        if bg_capture.ndim == 3:
            max_channel = np.max(bg_capture[..., :3], axis=2)
        else:
            max_channel = bg_capture

        return max_channel.astype(np.float32) / 255.0

    def _get_config(self, width: int, height: int, force_size: WatermarkSize | None) -> WatermarkConfig:
        if force_size == WatermarkSize.SMALL:
            return WatermarkConfig(
                margin_right=32,
                margin_bottom=32,
                logo_size=48,
                alpha_map=self.alpha_48,
            )
        if force_size == WatermarkSize.LARGE:
            return WatermarkConfig(
                margin_right=64,
                margin_bottom=64,
                logo_size=96,
                alpha_map=self.alpha_96,
            )

        if width > LARGE_SIZE_THRESHOLD and height > LARGE_SIZE_THRESHOLD:
            return WatermarkConfig(
                margin_right=64,
                margin_bottom=64,
                logo_size=96,
                alpha_map=self.alpha_96,
            )
        return WatermarkConfig(
            margin_right=32,
            margin_bottom=32,
            logo_size=48,
            alpha_map=self.alpha_48,
        )

    def _get_watermark_position(self, image_width: int, image_height: int, config: WatermarkConfig) -> tuple[int, int]:
        x = image_width - config.margin_right - config.logo_size
        y = image_height - config.margin_bottom - config.logo_size
        return x, y

    def _ensure_bgr_format(self, image: np.ndarray) -> np.ndarray:
        if image.ndim == 2:
            return cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)
        if image.shape[2] == 4:
            return cv2.cvtColor(image, cv2.COLOR_BGRA2BGR)
        return image

    def detect_watermark(self, image: np.ndarray, force_size: WatermarkSize | None = None) -> bool:
        """
        Detect if a Gemini watermark is present in the image.

        Returns True if watermark is detected, False otherwise.
        """
        image = self._ensure_bgr_format(image)
        height, width = image.shape[:2]

        config = self._get_config(width, height, force_size)
        x, y = self._get_watermark_position(width, height, config)

        x1 = max(0, x)
        y1 = max(0, y)
        x2 = min(width, x + config.logo_size)
        y2 = min(height, y + config.logo_size)

        if x1 >= x2 or y1 >= y2:
            return False

        # Use template matching for detection
        template = self.template_48 if config.logo_size == 48 else self.template_96
        image_gray = cv2.cvtColor(image[y1:y2, x1:x2], cv2.COLOR_BGR2GRAY)
        result = cv2.matchTemplate(image_gray, template, cv2.TM_CCOEFF_NORMED)
        _, max_val, _, _ = cv2.minMaxLoc(result)

        # Threshold for template matching: watermark detected if correlation > 0.3
        return max_val > 0.3

    def remove_watermark(self, image: np.ndarray, force_size: WatermarkSize | None = None) -> np.ndarray:
        image = self._ensure_bgr_format(image)
        height, width = image.shape[:2]

        config = self._get_config(width, height, force_size)
        x, y = self._get_watermark_position(width, height, config)

        x1 = max(0, x)
        y1 = max(0, y)
        x2 = min(width, x + config.logo_size)
        y2 = min(height, y + config.logo_size)

        if x1 >= x2 or y1 >= y2:
            return image

        alpha_roi_x1 = x1 - x
        alpha_roi_y1 = y1 - y
        alpha_roi_x2 = alpha_roi_x1 + (x2 - x1)
        alpha_roi_y2 = alpha_roi_y1 + (y2 - y1)

        alpha_region = config.alpha_map[alpha_roi_y1:alpha_roi_y2, alpha_roi_x1:alpha_roi_x2]
        image_region = image[y1:y2, x1:x2].astype(np.float32)

        # Reverse alpha blending: original = (result - logo * alpha) / (1 - alpha)
        alpha_clamped = np.clip(alpha_region, ALPHA_THRESHOLD, MAX_ALPHA)
        one_minus_alpha = 1.0 - alpha_clamped

        watermark_contribution = alpha_clamped[..., np.newaxis] * LOGO_VALUE
        original_pixels = (image_region - watermark_contribution) / one_minus_alpha[..., np.newaxis]
        original_pixels_clamped = np.clip(original_pixels, 0.0, 255.0)

        image[y1:y2, x1:x2] = original_pixels_clamped.astype(np.uint8)

        return image


class ImageFormat(Enum):
    JPEG = (".jpg", ".jpeg")
    PNG = (".png",)
    WEBP = (".webp",)


def get_image_writer_params(extension: str) -> list[int]:
    ext_lower = extension.lower()
    for fmt in ImageFormat:
        if ext_lower in fmt.value:
            if fmt == ImageFormat.JPEG:
                return [cv2.IMWRITE_JPEG_QUALITY, 100]
            if fmt == ImageFormat.PNG:
                return [cv2.IMWRITE_PNG_COMPRESSION, 6]
            if fmt == ImageFormat.WEBP:
                return [cv2.IMWRITE_WEBP_QUALITY, 101]
    return []


def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Remove Gemini watermarks from images generated by Nano Banana")
    parser.add_argument("--version", action="version", version=f"%(prog)s {__version__}")
    parser.add_argument("input", nargs="+", help="Input image path(s)")
    parser.add_argument(
        "--out",
        "-O",
        help="Output path (file or directory). If multiple input files, must be an existing directory.",
    )
    parser.add_argument(
        "--force-small",
        action="store_true",
        help="Force use of 48x48 watermark regardless of image size",
    )
    parser.add_argument(
        "--force-large",
        action="store_true",
        help="Force use of 96x96 watermark regardless of image size",
    )
    parser.add_argument(
        "--force-remove",
        action="store_true",
        help="Force watermark removal even if watermark is not detected",
    )
    return parser.parse_args()


def get_output_path(input_path: Path, output_arg: str | None, multiple_inputs: bool = False) -> Path:
    if output_arg:
        output_path = Path(output_arg)
        if output_path.is_dir():
            # Output is a directory: place file with _nowatermark suffix
            return output_path / f"{input_path.stem}_nowatermark{input_path.suffix}"
        # Multiple inputs but output is not a directory: error will be handled by caller
        return output_path
    # No output specified: use same directory with _nowatermark suffix
    return input_path.parent / f"{input_path.stem}_nowatermark{input_path.suffix}"


def main() -> None:
    """Main entry point for the watermark removal CLI."""
    args = parse_arguments()

    input_paths = [Path(input_file) for input_file in args.input]
    multiple_inputs = len(input_paths) > 1

    # Validate input files exist
    for input_path in input_paths:
        if not input_path.exists():
            print(f"Error: Input file not found: {input_path}", file=sys.stderr)
            sys.exit(1)

    # Validate output argument conflicts
    if args.out:
        output_path = Path(args.out)
        if multiple_inputs and not output_path.is_dir():
            print(
                "Error: With multiple input files, --out must be an existing directory.",
                file=sys.stderr,
            )
            print(f"  Specified path: {output_path}", file=sys.stderr)
            sys.exit(1)

    script_dir = Path(__file__).parent
    watermark_48 = script_dir / "watermark_48x48.bin"
    watermark_96 = script_dir / "watermark_96x96.bin"

    try:
        remover = WatermarkRemover(watermark_48, watermark_96)
    except FileNotFoundError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

    force_size: WatermarkSize | None = None
    if args.force_small:
        force_size = WatermarkSize.SMALL
        print("Forcing 48x48 watermark size")
    elif args.force_large:
        force_size = WatermarkSize.LARGE
        print("Forcing 96x96 watermark size")

    # Process each input file
    for input_path in input_paths:
        output_path = get_output_path(input_path, args.out, multiple_inputs)

        # Create output directory if needed
        output_path.parent.mkdir(parents=True, exist_ok=True)

        image = cv2.imread(str(input_path))
        if image is None:
            print(f"Error: Failed to load image: {input_path}", file=sys.stderr)
            sys.exit(1)

        print(f"Processing: {input_path.name} ({image.shape[1]}x{image.shape[0]})")

        watermark_detected = remover.detect_watermark(image, force_size)

        if not watermark_detected:
            if args.force_remove:
                print("Warning: Watermark not detected, but `--force-remove` specified. Processing anyway...")
            else:
                print("No watermark detected. Image unchanged.")
                print("Use `--force-remove` to apply the algorithm anyway.")
                continue

        result = remover.remove_watermark(image, force_size)

        if writer_params := get_image_writer_params(output_path.suffix):
            cv2.imwrite(str(output_path), result, writer_params)
        else:
            cv2.imwrite(str(output_path), result)

        print(f"Saved: {output_path}")


if __name__ == "__main__":
    main()
